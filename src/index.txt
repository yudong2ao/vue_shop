1、“···”ES6中拓展运算符，本质上是一种浅拷贝，用于复制对象，也可以和解构赋值连用，但必须放在最后。
2、解构赋值可以灵活地用来交换值，[a,b]=[b,a];
3、解构赋值接受函数返回值。
4、直接定义的匿名数组，数组中的值是放在windows全局下的，可以直接用a，b……访问。
5、数组和对象虽然都是对象，但数组是有序的，其有索引值，根据索引值查找内容，而对象是无序的，要查找对象内容只能通过属性值，for···in，对于数组而言是索引index，对于对象而言是属性名key。对象内容的获取，obj.key,这样key会作为字符串解析，不能用作对象遍历，obj[key],key会作为变量解析，可以用于对象遍历。基于index和key，数组的解构赋值按照顺序匹配，而对象的解构赋值按照key匹配，所以必须指定key值。对象的解构赋值中有一种高级用法，用于解决属性名冲突，foo:baz,在对象的解构赋值中，值是被传给了baz而不是foo。
6、在vue项目中，如果一个文件有“_”的前缀，一般表示这个文件在其他地方有引用，且编译器在编译时不会直接编译。
7、scss混合器，js代码复用产生了模块，UI复用产生了组件，html也可以通过vue循环简化书写过程，然而css代码的书写却一直较为繁琐，复用方法不多，现在css预编译器中的sass第三版scss中提出了混合器用于css代码的复用，通过@mixin前缀声明混合器，混合器中可以包含属性，css规则(css代码块)。通过@include前缀来使用混合器，复用的效率往往会因为复用传参这一高级用法而进一步提升复用效率。
8、scss文件是一种预编译文件，预编译文件在编译后会生成相应的css文件，但是有时候scss文件很多，却不需要生成太多的css文件，而scss有一个特殊的约定，即若scss文件的文件名以下划线开头，则scss就不会在编译时单独编译出css，而只是把这个文件用作导入，这样的文件称为局部scss样式文件，在scss中使用@import导入scss局部样式时，可以省略下划线前缀。css可以通过@import导入外部css文件，但是导入的外部css文件只会在执行到该处时才会调用，导致页面加载缓慢，而scss也有@import规则，但scss会在编译生成css文件时就把相关文件导入。css互相导入有继承关系，将局部scss导入全局scss，再将全局scss导入入口main.js,通常采用这种用法。
9、main.js是vue项目的入口，在这里导入的文件具有vue全局作用域，在这里通常引入vue,router,css,以及根组件app.vue,babel插件可以将es6转化为es5，但它只能转化语法，对于es6的api则无能为力，而babel-polyfill这个插件则可以将es6的api也进行转换。通过npm包安装的插件可以直接引用。
10、scss作为一种css预编译器，要使用就要先安装他的语法环境，node-sass，同时webpack在打包时，对于一些规格外的语言是无法直接识别的，要安装相应loader,如sass-loader.
11、vue web应用虽然可以使用浏览器原生的滚动条，但是由于各个浏览器样式的差异，滚动条样式差别较大，所以一般禁用原生滚动条，使用自定义的滚动条。将html和body的滚动条禁用：overflow：hidden;
12、固定定位一般是相对于视口进行定位的，但固定定位的元素的祖先元素具有transform时，固定定位不在相对于视口，而是相对于其transform的祖先元素。前端的发展很快，页面多终端适配，由rem，断点响应式页面，再到vm，rem+vm对页面的适配越来越好，可以说基础应用只要开发浏览器版本就好了，工程类应用才需要单机应用。
13、位置容器，在页面级组件中，我们都只是提供一些跟位置有关的容器，然后再把子组件填充进去，用于复用的组件我们是不写位置信息的，位置信息由调用组件的父组件定义和提供。
14、router-view路由容器，通过路由接入的页面都会在此容器中。
15、很多时候我们不用固定定位，因为固定定位的调整是完全独立的，不能随父元素变化，响应式差，通常使用相对定位来模拟固定定位。
16、组件一般用index命名，文件名index会被默认查找，vue、js、json后缀可以省略不写，所以引入组件只需写道目录一级。
17、组件,template；new vue(),export default{};分离式组件，一体式组件。export导出到了哪？（三块论述）
    (1)、new vue({})和export default{}的区别，前者是构造函数式创建一个vue实例，生成的是一个独立的vue实例，而后者是es6中模块的导出方式，从export default{}中的大括号可以看出导出的是一个对象，因为组件的复用，牵扯到子组件父组件的问题，而new vue({})创建的是独立的组件，子组件是用vue.extend(obj)方法建立的父子关系，所以需要传入一个对象参数，所以使用export default{}将相关参数封装成对象导出。由此也可以推出只要有父亲的组件都要用export default{}导出，而没有父亲的组件只有入口文件main.js里的vue实例，所以它使用new vue({})来创建。还有new vue({})里数据data是个对象data:{},而export default{}里数据data却是一个方法，而且数据是以一个对象来返回的，那是因为组件复用而对象又是地址传递，为了不让多个组件间的数据互相影响，使用函数和返回值。
    (2)、组件和模板template，组件是一种ui复用，最简单的组件仅有template组成，不过现实中谁会用这么简陋的组件，常用的组件我认为可以分为动态组件和静态组件，静态组件是写死的，由template和style组成，但大多数组件是动态组件，内容是活得，由template、style、script组成，数据，子组件，钩子函数，所有的高级用法都是靠script来完成的。
    (3)、一体式组件适用于小项目，缺点很多，不支持css，es5，预编译器，命名冲突，语法高亮。所以分离式组件(官方名叫做单文件组件)克服了以上缺点，应用十分广泛。
18、router-link可以作为块级元素，为router-link设置类名并设置样式，有时用router-link包裹独生子女央视无效，目前暂不知啥原因，所以使用router-link包裹复数子女吧。
19、router-link真的很厉害，以往点击效果往往需要先设置样类，再通过js循环保留激活项目样式清除其他项目样式。现在有了router-link直接设置一下激活样式就好了，其他的js代码router-link封装好了，不用管。
20、在main.js中引入的文件都具有全局作用域。组件之间js文件之间总之就好像是跨域一样，大家都是互相封闭的，谁也不认识谁，同时又共享入口文件main.js里声明的东西。
21、引入es6之后我们一般不在使用var,大多数的场景通过let和const就能解决，而且其实代码中很多数据都是静态的，后续业务层一般不变的，用const定义就好，只有很少一部分需要设置成变量let。
22、vue路由规则routes中的name属性好像看似没什么用，因为在规则中只要有path，component就行了。但其实name可以用来传参，也可以作为router-link的to的对象。
23、路由的页面加载默认是一次性加载所有页面，这样会让首页的加载速度变慢，vue还提供了一种懒加载方式，可以让路由涉及的代码在需要时再去加载。这里懒加载的语法是固定的，() => import('组件地址')，注意不能使用{}将import包裹起来，不然没法正确解析。
24、router-link高级路由跳转，是类似于a标签的点击跳转，可以自动变换地址栏，router-link的用法有两个:(1)、简单的<router-link to="/xxx"><router-link/>,to后可跟组件name和path，当to后的值是变量时to要加v-bind。(2)、更加高级的router-link :to="{}"传参，页面路由一定要用命名路由，不要用路径路由，因为路径路由有兼容性问题，在params里好像存在兼容性问题。在跳转组件时传递参数，参数用数组封装，常见的路由参数有name/path,params,query,params表示路由地址后的第一级伪地址，放在“/”后面，query表示第二级伪地址，params，query也是一个对象，query里的键值对放在"?"后面。在目标页面获取通过路由传递的参数时使用this.$route.params.xx,和this.$route.query.xx
25、异步操作，异步操作是啥？异步操作是从传统程序设计中引入的一个概念，要理解异步操作，就要先理解同步操作和线程，线程是cpu工作的基本单位，很多程序为了提高运行速度使用多线程技术--既同时在多个线程上处理数据操作，但刚开始的时候cpu是单核单线程的，程序在单线程上排队运行，这种程序运行方式叫做同步操作，但是就“同步”这两个字的理解似乎又不是这样，将异步操作，同步操作称为异轨操作，同轨操作更恰当一些。异步是并行，同步是串行。异步操作将部分操作从主线程中分离到子线程中运行，在主线程结束之后再将子线程上异步操作的结果注入主线程。异步操作的关键在于回调函数，也可以说异步操作的特征就是回调函数（为了数据的正确无误，必须将操作结果回调回主线程，浏览器会自动识别回调函数进行异步操作）。js是单线程的，为了实现异步操作，借助浏览器的力量，异步操作是在浏览器进程中进行的。***********************************************异步操作和同步操作从语义上的正确理解是执行顺序和书写顺序步调一致地叫做同步操作，执行顺序和属性顺序不一致的叫做异步操作。**************************************浏览器内核常驻线程有：gui渲染线程、JS引擎线程、事件触发线程、定时触发器线程，异步http请求线程。js解析时将事件，定时器，异步http进行异步操作，这些代码会丢给浏览器子线程处理，主线程完毕后，将异步结果（此时处于任务队列中）通过回调函数注入主进程。基本的回调函数式异步操作只能将dom操作，事件，定时器，ajax作为异步，因为这些是常见的耗时操作，使用这些异步操作的话，可以真正的利用多线程提高代码运行效率。如果自己的js代码里也有耗时操作又不涉及基本耗时操作的话，就需要自己用回调函数再加异步请求和异步响应封装高级的异步操作，但这样只是让代码运行效率提高，总的时长是一样的，并没有利用多线程。es6中引入了promise对象，简化了自定义异步操作的过程，promise对象中的回调会被放到任务队列中。*********************回调函数说白了就是被作为另一个函数参数的函数，回调函数本身没有同步异步之说，可以被用在同步处理也可以被用在异步处理，基本的回调函数异步操作只能把dom，事件，ajax，定时器进行异步处理。高级的promise可以将自定义代码段以为异步处理。同时又避免了回调地狱(3重以上的回调嵌套)。
26、引入图标字体时，千万别忘了图标字体要设置两个类名，一个公共类名，一个个性命名。有时会因为没有公共类名查找半天的问题。哎……衰！
27、并集选择器用的不多，但也不能忘记啊，就是直接连写，没有间隔。
28、slot，又称为插槽，是vue中的一个内容分发接口，在模板中创建插槽，组件在被调用时组件标签之间的值(所有任何类型的值)会被放入插槽中。插槽有匿名插槽和具名插槽。组件标签间的值默认放入匿名插槽，要放入具名插槽就要指定插槽名，<slot name="xxx">,<div slot="xxx">使用类似这样的结构就可以将值插入具名插槽。
29、flex布局的项目一旦设置定位，相关的flex属性会失效，解决方法是加一个壳。将flex容器和项目的外围再套一个壳，对最外围的壳添加定位。flex和fixed，absolute组合时会flex属性失效，因为这两种定位脱标，而flex和relative组合时flex相关属性不会失效，因为relative和flex都不会脱标。
30、flex布局和ellipsis存在冲突，flex项目中的省略号无法调出。目前认为这是一个浏览器的bug，解决方法有好几种，只是不知道哪一种最靠谱。(1)、text-align：center可以在文字不足以填满容器时，将文字居中显示，在文字超出容器且溢出隐藏时从起始位置显示文字。(2)、flex布局中的justify-content和align-item都是相对于容器居中对齐，在文字不足以填满容器时，居中显示，在文字超出容器时仍然将文字的中心位置和容器中心对其，以至于在文字超出容器时显示效果巨差。(3)、text-align可以很方便的用overflow:hidden;white-space:nowrap;text-overflow:ellipsis;将溢出的文字用省略号表示。但是将这三个属性在flex项目中直接使用的话，没有任何效果。但是flex项目好像只有一层，flex项目里面的其他容器不再和ellipsis冲突，所以将文字再封装一层就好。对封装后的文字设置以上三个样式后，就可以神奇的(其实也不神奇，就是flex布局只有一层，很多效果要对内封装，对外封装，因为flex和定位等很多原有属性冲突)将文字效果调整地和text-align一致，既不满时居中，溢出时从头显示末尾省略号。
31、props父组件调用子组件时传值，子组件中在props里定义一个形参，并使用这个形参，父组件在使用子组件时直接将实参传入，传参时可以传入一个常量，也可以传入一个变量，但是传入变量时必须在用":"(也就是v-bind)
32、有时字体过大，行高不足导致的部分字“掐头去尾”问题，只要把行高调成1.x即可。
33、任何编程语言都会留有跟错误相关的api，try、catch、throw、finally是js里跟错误相关的api，不同的编程语言之间具有很多相似性，基本语法的相似，自带api的相似性。try用于测试代码块，catch(err)用于和try搭配使用，当try中的测试代码存在错误信息时，catch会捕获到这一错误，并显示出来（catch会在捕获到错误后创建一个err对象，包含name和message）。throw是另一个搭配使用的api用于手动抛出一个错误，本质上是抛出了一个error对象，不管是手动抛出的错误还是try里检测到的错误，遇到错误都会直接跳到catch(error)里。fianlly用于在try和catch后执行，不管结果如何都会执行。
34、webstorm也太智能了吧，移动文件时会自动修改引用路径。对组件名称的更改会自动将所有引用里的名称也更改。
35、vue项目工程化时推荐建立公共组件和基础组件，所谓公共组件是完善的成型组件，其他页面和组件可以直接调用，而基础组件只是一些半成品，是抽离出的一些基本公共结构和样式，使用时要根据不同页面二次加工。vue项目要建立pages目录，components目录，base目录，而assets目录是默认存在的，需要在其中建立各种类型的资源文件夹。pages里每一个页面目录都包含众多组件，其中index组件是主组件，其它业务组件被填充到主组件中。页面相关的文件在页面文件夹里就近维护，pages以外的文件和文件夹都是共有的，这样一个项目结构是很妥善恰当的。
36、vue组件名(vue组件中的name属性对应的值)不能和html标签名冲突，不然会报错，当然这里就算报错，也是可以正常显示的。
37、vue中的一类特殊对象，prop对象，常用的props既是prop对象的集合，
prop对象可以指定类型，可以直接指定类型，如propa:Number,其中类型值不用引号引起来，当需要给prop对象指定多个属性值时采用如下形式：propb: {type:String,default:"s",require:true,isVaild:function(value){}},类型值不用引号，因为在js中，包装对象首字母大写，可以全局识别。不需要加引号作为字符串转换。type，default，require都是prop对象默认的key，不能更改。require表示父组件传值不满足时直接报错。在prop对象中可以自定义验证函数，也可以使用props自带的validator函数，但validator和自定义验证函数只能使用一个。
38、默认情况下，js和css一样只能使用自身定义的代码，如果要使用别的js和css代码，就必须引入这个文件，但是这样的话就必须把整个整个文件引入，不可避免地提高了代码冲突的可能性，为此，有了scss中的混合器mixin和es6中的模块export，这样一来使用include和import就能引入一部分代码，极大地减少了代码冲突。
39、windows认可的可执行文件有.exe,.bat,.cmd在命令行中运行的也只有这三种文件
40、slot插槽有匹配性，匿名html放入匿名插槽中，如果不给匿名html指定slot是没办法放入具名slot中的。vue组件模板template中必须用一个元素包裹，此元素可以是自定义的vue组件元素，既可以是子组件。因为各种声明之后可以被vue解析器解析为块级元素。不同的组件(子组件和父组件)之间可以使用相同的class名，样式不会冲突，解析器在解析时会自动添加区分页面级组件因为要引入很多子组件，所以给子组件加上一个容器，避免子组件间互相影响，也就是页面级组件仅提供一些容器和相应布局，子组件填充进容器即可。简单组件(只包含一个子组件)直接包裹子组件就行，不需要再在子组件外添加容器了。但是如果一个组件包含了两个及以上的子组件，就需要用容器包裹，因为这样可以分离式开发，不同的人负责不同的组件，并且父组件可以在不知道子组件的情况下完成开发。
41、有时候父组件传值传的值并不是我们想要的，但并不会报错，js解析器只能识别好像是六种基本错误吧，如果父组件传了一个我们不想要的值，导致没有出现想要的效果，我们是很难查出此类错误的。所以我们通常对此种情况进行传值校验，当传值是不想要的值时主动报错，帮助我们查找错误和dbug。
42、export default作为模块导出时，默认导出匿名模块，相应的在导入此匿名模块时要给它取个名字。而export导出是导出具名模块的，因为具名所以导入时不能自己再给它取另一个名字，导入时需要用花括号{}包起来模块名，这都是es6模块语法。
43、元素脱离文档流之后，因为不再是块级元素，自身的宽度萎缩，不会再占据整行，所以需要人为设置宽度。同时父元素会高度萎缩，所以要格外注意，将一个元素脱标时要考虑这两点。
44、vue组件和第三方插件往往会对元素预设一些类名，有时要实现相应的效果不得不参考他们的类名针对性的编码。
45、在某些情况下，错误是不可避免地，当我们预料到这个错误时，可以主动的抛出这个错误，通过throw，但是其实是建立一个Error对象，并抛出这个对象，这样预料内的错误不会导致程序中断，可以继续执行。
46、webstorm的代码补全和智能提示是依据其项目索引和缓存的，webstorm在打开项目时会更新索引。有时索引会出现一些奇怪的问题，导致项目跑不起来出错，此时可以通过file-invalidate caches/restart来清除和重建缓存。
47、es6箭头函数有三种情况：具名和匿名，有参和无参，单句和多句。eg:f=()=>{a+b}.谨记以下几点：箭头相连的是参数，匿名函数不写“f=”这样的结构，参数只有一个时“()”省略，语句只有一条时“{}和return”省略。当返回单语句对象时，必须将对象用“()”括起来。但是如果具名函数无参时，“()”不能省略，否则函数名会被当成参数。对参数和函数名的区分是通过“=>”来区分的。
48、data里只是定义数据，数据的操作函数的调用什么的不在能在data()里定义，不然无效。data里只放数据，不对数据进行操作。methods里只定义方法，不调用方法。调用方法在钩子函数和事件里调用。这些都是有严格定义的，不能不按照规定使用，不然虽然不会报错，但是操作会无效。外部函数的直接调用是不能操作内部数据的，内部数据的操作必须定义在methods里，而且钩子函数和事件只负责调用不能定义其他操作。
49、异步操作promise对象，promise对象有一个匿名函数作为参数，该匿名函数有两个函数作为参数，resolve和reject这两个函数有js引擎提供，作用是改变promise对象的状态并将异步操作的结果(成功时是value，失败时是error)传递出去。then则接受两个函数作为参数，分别是成功时的函数和失败时的函数，函数的参数分别是value和error。***********************************************promise对象新建后就会立即执行。
50、then()也是promise对象默认的函数，是有js引擎提供的。只有promise对象才能调用then(),then()和resolve()以及reject()函数都是事先有定义的：返回一个对象，对promise对象的状态值和返回值的定义。个人重写的部分具有较高的优先级，没有写的以默认为准。因为then()返回一个新的promise实例，所以才能链式调用。返回值会被传出去，作为新的then()的参数，且then()里的参数只是形参，实参会由vue自动填充，不用关心这一点。
51、created()和mounted()函数作为最常用的两个钩子函数，其区别主要是dom是否渲染成功。created是实例已经被创建，在这一步会完成数据观测，属性和方法的运算，watch/event事件回调，调用获取远程数据通常在这一步完成(通常指获取后台数据)。mounted中，dom已经被渲染，可以进行一些数据的填充。
52、v-if和v-show的区别，v-if是根据条件去渲染页面，v-show是根据条件去决定是否显示页面，有时swiper插件在没有获取到远程数据时就去渲染页面的话会带来一些bug，这里是轮播图的最后一页无法正常切换到第一页，此时只有给swiper加上v-if渲染条件即可，当获取到远程数据之后在进行渲染即可消除此bug。
53、在程序开发过程中，很少出现一些无意义的数字，为了提高语义化，往往将一些数字定义为常量或变量。
54、promise.catch()就相当于promise.then(null,reject)或promise.then(undefined,reject),当异步失败或遇到错误或者是主动抛出错误时，就被catch捕获，程序自动跳转到catch中。
55、一般来说无论是axios，jsonp，ajax等前后端数据交互时都应该定义请求配置如超时什么的，不然数据出不来有找不到错误就尴尬了。
56、解构赋值的全称为变量的解构赋值，也就是说常量const是不能进行解构赋值的。
57、data里的属性和mothods里的方法要用this才能访问。then()这个方法是可以连续调用的，且promise中的每一个then的参数都是上一个then方法的返回值。
58、promise嵌套和链式调用。setTimeout()参数问题？setTimeout()的函数参数常常是匿名函数，因为超时调用是以后调用，所以不能写成函数调用，写成函数的形式又不能灵活传参，所以常常写成匿名函数的形式，干脆就记住只能写成匿名函数得了。当然还可以将带参函数用单双引号搭配使用以完成参数传递
59、vue别名和“~”，在webpack.base.config.js文件中可以使用alise，通常自带@表示src目录，还可以自己定义一个‘#’，使用resolve('src/……')来定义别名，至少在vue2.x中是这样的，不过CSS-loader(webpack中的css解析器)会把非根路径的url解释称相对路径，加了‘~’前缀才能解析成模块路径。在vue里路径可以分为绝对路径和相对路径以及模块路径(使用别名减少路径长度的方法就是引入了模块路径)。所以使用css引入模块路径时要加上前缀‘~’，但是在webstorm中，自定义的别名不适合使用特殊符号“#”。这一类的符号，ide会无法识别而报错，所以建议用单词或常规字母作为别名。
60、前端开发中各种命名规范，命名规范的好处是语义化便于理解(当然这里的便于理解是因为通常命名时使用多个单词的组合)，同时便于语法检查(多个单词的直接组合有时会被ide标记，有时错误的单词拼写也会被标记，多个单词使用“-”或“_”组合而不是直接组合就不会被ide标记，这样就提高了真正错误被发现的概率)。通常项目组会有相应的命名规范统一各个部分的命名。在个人开发过程中，如果条件允许建议使用“_”来，因为单词的直接组合并不具有机器语义，不利于ide识别，而unix,linux,和很多标准组织对下划线的支持度更好，所以不到万不得已不要使用单词直接连接或驼峰命名，可以的情况下最好使用“_”。而且单词直接连接和驼峰法性能较差。更：***************************css中“_”有兼容性问题，所以css语法才会强调使用“-”。综上所述，这个前端还真是尴尬，js要用驼峰，css要用“-”，其余的要用“_”或“-”。尴尬的一批。
61、项目依赖的包最好不要全局安装，因为一旦全局安装后，在构建别人发来的项目时，检测到全局存在就不会安装已经全局存在的依赖，事实上有可能全局存在的包和项目依赖的包版本号不一样，有可能依赖的兼容性不佳导致版本号不同而构建失败。还有npm包的范围详细的可分为本地安装和全局安装，本地安装是在当前目录下安装，默认会在当前目录下建立./node_modules文件夹用来放置依赖，本地安装只在项目目录下可用。全局安装又分为系统全局安装和用户全局安装，系统全局安装的依赖被放在node安装目录下的node_modules目录中，不同用户都能使用。用户全局安装的依赖被放在用户目录下的node_modules目录中，默认全局安装就是用户全局安装。
62、npm与cnpm，cnpm安装依赖时有时会遗漏部分依赖，且错误信息的提示不太准确，有时cnpm没有报错，项目却跑不起来。npm报错信息准确，有错就跑不起来。有时项目的错误如果不是自身编码的错误那就一定是环境和依赖的问题，环境的问题一般因为兼容性很少出现，依赖的问题倒是经常出现，其实可以直接删除依赖node_modules文件夹，然后再重建一般就解决了问题。那么这个问题往往是因为项目建立时使用cnpm install安装了项目依赖，然而使用cnpm会导致在使用npm时缺少很多依赖库，无法运行。所以不能用cnpm。而且在自主安装依赖时一定要明确是开发时依赖还是生产时依赖，这对项目的实际上线时的大小和流畅度至关重要。
63、有时项目依赖的层级很深，互相依赖了好多层，导致无法删除依赖，此时可以使用rimraf来删除。
64、git中https和ssh的异同，使用ssh必须实现配置公钥，验证通过才能clone，https可以直接clone。但是https在push时每次都需要验证用户名密码，而ssh不需要验证，可以直接推送。通过git pull拉取代码来更新项目比下载压缩包方便也合理，直接下载压缩包是下载了最新版文件不包含git和一些特殊的文件。
65、双斜杠加todo会形成todo标记，在todo后面的代办项会在todo标签里显示，可以很快从中断的工作中恢复。
66、不正确的关闭或者网络问题会导致依赖包错误，产生一些莫名其妙的错误，需要删除依赖重新下载。
67、在vue-cli是vue-cli 2.x，而vue-cli 3.0以上因为有重大改动，所以改名叫vue/cli，其中一处改动是alias别名设置，在vue-cli中vue别名需要在webpack中设置，而且css中的别名要加上“~”前缀。****************************************(～￣▽￣)～大更新，原来一直以来的alias别名使用失败，是因为没有在webstorm中导入webpack的配置文件。
68、在项目中安装依赖 --save表示安装到生产环境，但其实在生产环境和开发环境都可以使用，所以我觉得前面说的“--save表示安装到生产环境”说法不准确，是一种陋习，叫做安装到生产和开发环境较为准确。--save-dev是安装到开发环境，跟webpack相关的依赖都是建议安装在开发环境，因为webpack只工作在生产环境之前。检出仓库（checkout）本质是clone仓库的衍生版，一个git仓库有三部分组成，工作区（workspace），暂存区（index），最终区（head），工作区add到达暂存区，暂存区commit到达head区，从逻辑上将每次commit都是把暂存区提交到最终区，所以必须执行add将修改提交到暂存区。但是“commit -a”命令可以将add和commit结合，自动先执行add，然后执行commit。checkout是检出的意思，可以灵活的切换分支，要切换分支就要先建立分支，git breach xxx
69、69、不知道为啥在webstorm中别名不能使用“#”这一类的符号，但是可以使用常规字符，说是不能使用但其实只是标红，没有报错，可以正常编译，但因为无法识别所以不能很好的进行代码补全和代码提示。
70、v-bind在最开始接触时说是用于属性绑定，这是基本操作，也是基础操作，v-bind也可以用于对象绑定实现一些高级操作，常见的是通过给v-bind的对象绑定动态的切换css，例如v-bind:class="{'button-on: x变量'}"通过变量x控制button-on类的显示与否，因为同一元素的多个类名，后面的会覆盖前面的。
71、父组件向子组件传值时，如果值的类型是字符型，是可以直接传进来的，但只如果值的类型是非字符型，就必须用变量封装一下才能传进去。这是因为传值是作为组件的属性传入的，而其样式是prop=“xxx”，所以只有字符型可以直接传入。
72、在vue里不提倡使用定位，层级进行完全覆盖，那样渲染效率不高，建议使用v-if，v-show进行可选的显示和隐藏，且当v-if之间存在对立关系时应该改为v-else减小系统判断的开销。
73、swiper插件极其强大，基础的swiper和swiperSlide是引入后才能作为标签使用的，其他的分页器，导航条，滚动条等都是使用div和slot插槽完成的。其中各类辅助组件的类名和插槽不能写错，swiper就是通过这些插槽和类名完成的。
74、我现在猜测组件在引入之后是可以直接作为标签使用的，组件样式有两种一种是在引用前的基础样式，基础样式可以直接在基础组件上添加类名也可以在调试工具里查看系统添加的类名然后配置样式。引用之后如果想设置样式的话就必须封装一层，把类名设置在外层上，并添加相应样式，在组件标签上添加类名或者使用系统默认添加的类名设置样式都是不起作用的。
75、一个s引发的惨案，swiper组件中，传参的prop是options，我写成了option，真是可耻啊，查了2个小时没搞出来，就是个这东西啊。
76、为什么vue中script部分引入本地图片必须使用require。解：require命令是nodejs提供的模块导入命令和es6里的import都是用于导入模块，因为import在设计时主要考虑到浏览器需要从服务器端加载模块，所以import主要是异步加载（当然也可以同步加载），而nodejs加载模块主要是从服务器端，也就是本地加载，所以node没有使用es原生的import而是处于性能的考虑使用了主打静态本地同步导入模块的require，而且nodejs的require的产生和使用要早于es的import，require是即刻导入，而import则是异步使用时才会导入。还有什么时候数据放在data(),什么时候放在mounted(),大概就是本组件数据放在data里，通过父组件传入的数据放在mounted里，网络获取的数据放在created里。data()里的数据会自动进行数据绑定，vue会自动添加set和get监听data()里的数据，每一次数据的变化都会引起重新渲染，所以如果一个数据基本上很少变化，从页面性能的角度考虑，就不要把该数据放到data()里，与之相对的建议放到mounted()或者是created()里。数据尽量不要直接写入，建议存储到变量中，便于后期修改。
78、如何使用jsonp跨域，为什么要使用jsonp插件，axios和jsonp异同，淘宝开放api让别人使用，get，post，jsonp,ajax,axios,async,await。get和post是ajax的数据请求方式。ajax是es内建支持的前后端数据交互技术。promise可以处理ajax这样的异步请求，async，await都是在promise基础上改进的异步处理方式。axios是封装了promise对象的第三方插件。jsonp是跨域解决方案。
79、require是nodejs提供的api用于引入模块，使用commonJS规范编写，javascript有基本的语法和基本api，称之为es部分，其他的根据宿主环境的不同，还提供一些额外的api，比如在浏览器环境中提供bom，dom，web三类额外api。而在服务器环境则提供各种操作系统的API,比如文件操作api，网络操作api等。前者的浏览器环境包括各大内核的浏览器。后者的服务器环境目前主要指nodejs。
80、js默认不允许跨域，所以从逻辑上分跨域的解决方案可以分为两种，前端解决方案和后端解决方案，前端主要时利用html中src可以跨域的特性。后端主要是利用端口和域名的配置来解决。axios是基于promise对象封装的，promise可以使用ajax，所以axios也可以使用ajax，也正是因为ajax不能用于跨域，所以axios也不能用于跨域。******************通常来说ajax是不能用于跨域的，所以axios也不能用于跨域，但是http官方引入了CORS技术，是的ajax可以进行跨域访问，得益于此axios中使用CORS技术也可以用于跨域访问。
81、get方法常用于获取数据，而post方法常用于提交数据（表单提交，文件上传），当然post也可以用于获取数据，只能一般从语义化的角度上不这么做，除非要获取的数据比较特殊（get无法完成特殊数据的获取），才会使用post获取数据，put会把所有本地数据推向后端，常用于全面的更新数据，而patch也用于更新数据，只是patch只能将修改的数据推送到后端，delete用于删除数据。当然这些都不是固定的，也可以和后端联系改动。post、put、patch非常相似，虽然可以是post取代另外两个来使用，但这样是不符合规范的。axios的方法有别名调用和参数调用，别名调用使用axios.get/post/put/patch/delete('url',参数，config)的形式去书写，而参数调用使用axios({
  url: '',
  method: '',
  data/params:{},
  ......
});其中只有url是必须的，且get方法会把参数放在url后，所以可以直接在url里面带上params，也可以把params对象单独拿出来：axios.get('/user/12345',{params:{id:12345}}),'{}'中的数据都是config的参数，别名调用和参数调用在参数方面的区别就是把一部分参数从config中提取出来。且data参数是post、put、patch共有的。timeout是很常用的参数，表示超出此时间，将会抛出请求超时。delete发放可以删除数据，如果要删除的数据在url中，可以使用params，如果要删的数据不在url中则使用data
82、路由懒加载：()=>import(xxx),减少页面加载的等待时间。原来浏览器第二次访问同一个页面时，会根据缓存中有无来进行重定向，如果缓存中已有就会重定向到缓存，不会更改页面。axios.post进行前后端数据交互时存在两种数据格式，form-data(表单提交，用于比较老的网页，一般用于老页面的图片上传和文件上传)，application/json(使用json数据格式进行数据传递，目前大多数网页会使用这种新式的数据交互方式。)，json的数据传递比较简单，但是formdata不太好用，就是使用formdata对象的append()方法。
83、axios并发请求就是同时进行多个axios请求并统一处理返回值。axios并发请求使用axios.all()和axios.spread()方法，axios.all()中的参数是一个数组，数组里是各个axios请求，axios.spread()方法在作为then的参数将axios.all()的返回值作为参数。
84、jsonp插件的使用：jsonp(url,opt,)***************************原来vue中跨域很灵活啊，虽然浏览器禁止跨域访问，但是服务器端是允许跨域访问的，只要进行配置使用本地服务器访问远程服务器，再由浏览器调用本地服务器数据即可。通常最常见的跨域方式有原生jsonp，jsonp插件，CORS，proxy和nginx反向代理是两种不那么常用的跨域方式。
85、script标签中的src属性可以跨域访问js脚本，利用这个特性，服务端不在返回json格式的数据，而是返回一段函数调用（函数调用的参数就是要传递的json数据）。这一段js脚本到了本地后，会去全局作用域查找js脚本里定义的函数是否存在，所以本地需要再全局作用域定义好对回调函数，同时再向后台请求数据时传参指明回调函数的名字，这样后端才能配合生成指定的函数封装，这样前后端配合就实现了跨域数据访问。jsonp在url中传入回调函数名，这种直接在url中传参的方式不就是get吗，所以说从原理上json只能使用get这种方法。而且在实际使用中往往动态的创建一个标签元素去进行src请求。jsonp返回的是一个函数调用。所以必须在全局里有定义才行。原生jsonp兼容性极佳，但是jsonp的错误处理机制不完善。
86、一般来说，一个项目在需求阶段要拿出功能原型和交互原型，软件设计人员根据原型列出接口（api），前后端开发人员审核调整接口，在一些大的项目里接口是由专门的前端人员去设计的，之后交给后端人员实现这些接口，设计好之后尽量不去改动。之后前后端开发人员就可以分别编程了，通过接口设计整合前后端是前后端分离的基础，这样才能大幅提高现代软件开发的效率。软件开发的效率提升关键在于通过接口设计前后端分离，前后端并发进行。同时接口设计是紧随在原型设计之后的，由前端和后端共同完成。一般后端回来问前端需要哪些数据。也就是说前端要懂后端的知识，只是不亲自去编程而已。果然知识面限制了前后端接口定义的舒适度。接口设计先于编码，只是必须的要义。
87、一般来说项目中的接口文档由一个熟悉前后端开发的类全栈开发人员完成，接口文档一般由后端来写，只是需要事先和前端商量定义，之后编写接口文档并维护至项目结束。通俗来讲：前端提出接口需求，后端写出接口方案，一般前端接口需求由前端大佬完成，后端大佬定义接口。之后前端完成界面和接口调用数据填充，后端完成数据库维护和接口定义。一般来说接口分为四个部分：方法（post、get、put、delete）、url、请求参数、返回参数。接口文档的编写有很多支持markdown语法的在线api工具：showdoc、apidoc、sosoapi、eolinker等可以很方便的进行团队协作，可以在线查阅和离线导出。一般先写页面，当页面需要数据填充时，就去查阅接口去写接口调用。
88、spa应用大多以功能交互型为主，js代码过10万行很正常，现代软件开发流程前后端分离前端的工作量陡然上升，很多工作放到前端来做，前后端同步开发过程中，有时前端只能假设已经获取到了后的端数据，然后在看不见的情况下进行开发，等到最后的联调测试阶段才能看到页面效果。
89、RESTful是目前最常用的一组接口设计规范，其以http协议为基础，api方法推荐使用get，post，put，patch和delete，并分别用于获取，新建，全部上传更新，部分上传更新，删除，对于http协议中的其他head，options……一般不建议使用，且api的url中不使用动词，使用和数据表中相对应的名字或名词复数组成url，一般不使用动词。且状态码的定义建议和http协议保持一致。
90、同源策略其实并不是不允许发送跨域请求和接受跨域响应，而是在接受跨域访问之后将跨域内容封存，使得本地js不能调用跨域相应内容，CORS跨域资源共享机制使得浏览器允许跨域资源访问，axios或者使用xmlhttprequest的地方都可以使用cors，以及web字体和webGL贴图都可以使用CORS进行跨域，需要服务端配合处理请求头并返回响应头。*****************************原来最初CORS是在Fetch规范中定义的，Fetch规范是由浏览器推出的技术标准。cors请求分为简单请求和非简单请求，简单请求可以直接发起cors请求，非简单请求则要先发起预检，预检通过后才能发起cors请求，简单请求要满足三点：(1)、方法为get、head、post之一(2)、cors头部字段为accept、accept-language、……9个之一(3)、content-type的值仅限于：text/plain,application/x-www-form-urlencodeed,multipart/form-data三者之一。CORS是由浏览器推出的技术，需要浏览器和服务器共同支持，所有的现代浏览器和ie10以上都内置了对CORS的支持，前端在使用CORS时几乎不需配置，浏览器在检测到跨域访问时会自动添加cors请求头。能不能使用跨域的关键是服务器端是否进行了相关配置，服务器端配置的内容有允许跨域的域名，方法，content-type。当请求域名在远端服务器的配置中，或者远端服务器设置了对所有域名允许跨域访问就可以进行简单访问。对于携带cookie的非简单访问，前端需要在withCredetials设置为true。CORS优势明显，官方支持，可以使用任何类型的请求。get传递参数是以“？”开始的，get可以传递多个参数，参数之间用“&”连接。
91、函数名和函数体分属不同的作用域，所以才需要return将结果抛到外层以便使用，一旦一个函数被调用，对于一个外界来说，就只有return的部分可见。函数内部的可执行语句只有在函数调用时才会执行不过函数体内部的函数调用可以认为已经执行，这样就局限在父级作用域又不会函数调用太多分析层级困难，而且便于分析程序运行结果。为便于分析，函数被调用则把函数被调用部分换成返回值部分。
92、有时远端服务器是不允许CORS跨域的，如果远端服务器要允许的域很多，那么便很难把这些域名加入允许列表中，使用通配符*去允许所有域名的话又存在安全隐患，所以此时常常使用jsonp跨域。
*****************************************************************************************************************************************一切用不正当手段得来的东西都没有意义，那样是绝不可能获得幸福的，天道还是好轮回的，苍天还是有眼的。
93、字符串方法大多是由slice()演化来的。
94、前端工作大致上分为界面层和数据层，界面层侧重于ui还原设计稿，数据层要封装，获取，校验，调用数据。
逻辑是封装通用的接口函数，创建一个调用接口函数并传参的函数(对通过接口函数获取的数据进行校验等相关操作再返回)，在相关页面执行函数调用获取数据。就算是直接的传参调用，也要进行数据校验。
95、钩子函数created和mounted的区别主要在于created在模板渲染成html前调用，mounted在模板渲染成html后调用，且在实际开发开发中created比mounted使用频率要高，钩子函数里的语句会在每一个生命周期自动执行。
96、promise对象的rejected(err)和resolved(res)可以将err和res返回，但是如果不运行这条语句的话，好像是不起作用的。还有then()里如果没有返回值，好像默认是返回undefined，
97、数组和字符串是最常见的操作对象，数组方法和字符串方法中用的最多的就是字符串/数组拼接，分别是“+”和concat(),字符串提取/数组提取都可以是slice()
98、路由传参使用':to={}'，且只能使用路由名，不能使用路径名，vue作为单页面应用，大多数页面的跳转都是通过路由来完成的，没有直接使用网址来跳转到，而且在路由跳转中传参是很常见的操作，所有路由名是必不可少的，子路由用chlidren
99、promise对象是一种特殊的容器，promise对象可以链式调用，通过then、catch自定义promise对象的回调函数，通常来讲链式调用都是使用使用return将主操作数返回，对于promise对象也不例外，每个promise对象返回一个新的promise对象，所以可以链式调用，但是在日常使用过程中，我们常常自定义返回值，其实不管是我们自定义的返回值还是通过resolve(xxx),rejected(xxx)返回的值都不是真正的返回值，promise对象会对我们自定义的返回值进行一层封装，使之和resolve(),rejected()一样，被默认传递到下一层链式调用的promise对象中。promise对象就只是一个容器，把一些需要的异步操作放到里面就行了，但是只有初始状态的promise对象可以放置异步操作，then(),catch()之类的promise属于衍生promise对象，不能把异步操作放进去。而且衍生promise对象没有resolved和rejected方法。
100、有时获取数据进行校验时一定要注意状态码的值和类型，有时状态码不是数型，而是字符型，从而导致数据校验一直通不过。还有console.log(xxx)在webstorm中可以用'xxx.log'再加tab键完成。
101、使用es6的箭头函数一定不要轻易使用this，因为箭头函数的this指向性不同于传统函数，容易导致错误，其实这一次查了一上午才发现错误是由于在vue的methods中使用了箭头函数导致。对象是js里最重要的数据类型，变量和函数如果位于对象内部，就称之为属性和方法，且属性和方法必须使用键值对将key和value分离，但是在es6中引入了对象的简写方法，具体就是可以直接写入value，不写key，此时默认key和value相同。这在es6模块中是非常常用的。
102、常量和变量并不像自己想的那样，只有一个量不需要再程序中动态的变化，那它就是常量，这里要分清在程序中变化和在项目中变化，在程序中变化定义成变量，在程序中不变化就定义成常量，可见以前的程序存在滥用变量的问题。
103、正常情况下，实现文本溢出自动显示省略号是很简单的，有三个属性，先设置溢出隐藏：overflow：hidden，在设置文本溢出的处理方式：text-overflow：ellipsis，最后是制造溢出的条件即：white-space：nowrap。有时多行文本溢出省略号，就必须考虑到文本换行的断字问题，当然使用多行溢出省略号就要指定高度或行数，而不使用white-space了。white-space是个很常用的属性，因为在开发过程中，无论我们敲多少空格和换行符在页面上都会只显示一个空格，无论我们一行打了多少字符，页面上都会自动换行，除非放不下才会隐藏。但是实际的开发过程中，要求总是多种多样的，所以有了white-space这一属性，white-space可以灵活的处理页面中的各种留白。代码编辑过程中留白有空格，换行符，制表符，制表符只是便于代码阅读的一种代码风格，没有实际意义，所以页面显示中要处理的空白实际上只有2种，空格，换行符。默认效果是自己打的换行符和空格都被合并为空格，文本自动换行，这也是white-space的默认属性normal，white-space的属性很优秀，nowrap是合并自定义换行和空格，不自动换行。pre是预设输出，手动换行和空格不合并，不自动换行。其他的不常用，用了再查。
104、-webkit-line-clamp属性可以把容器内的文字限制为指定的行数，并用省略号填充尾部。要使用这个属性必须同时使用display：-webkit-box和-webkit-box-orient:vertical,这个属性是由webkit引擎支持的私有属性。但是已经被很多浏览器所支持，基本上除了ie和较老版本的firefox之外，都支持这一属性。
105、如果自己设置的样式不起作用，那就进浏览器打开开发者工具查看一下是否是所用框架自主添加了一些容器，导致样式不生效。还有scss中样式的嵌套和类名的嵌套完全不同，因为不从形式上进行区分的话浏览器就无从分辨，可能渲染出错，类名的嵌套是在{}里面用'&'号，属性名的嵌套是在{}的外面用':'。
106、在自适应布局中，图片宽度往往随设备宽度变化而变化，高度有时也需要随宽度变化，这里有一个很好的方法实现这个效果，利用padding-top百分比取值和宽度百分比取值，实现容器的自适应缩放而且固定比例，再利用背景图片实现图片居中显示，简直完美，如果不用这种方法的话，往往需要利用复杂的js代码
107、不得不说，对于学习来说，最正确无误的方法是查看官方文档，网上各种教程参差不齐有着不少的错误或片面的见解，很容易一知半解的情况下造成畸形发展。所以任何事物以官方文档为主，任何第三方解读都容易造成误解。
108、原来background这一简写属性是包含了background-size的，这和之前一直以为的不同，或者说受到了第三方言论的误解，只是background-size在简写时必须放在background-position后面并且使用”/“而不是” “才能生效。如center center/cover。简写属性在使用时要格外注意，没有指明的属性值都会按照默认值，如果简写属性的优先级较高（比如内嵌属性），后面自定义的属性就会无效。
109、v-bind属性绑定，当要操作的属性较少为一个时，可以直接绑定，当属性较多时可以使用对象{}封装这些属性，此时可以直接封装属性也可以间接的封装一个类名来实现。v-bind时vue默认语法在设计之初就考虑到了关键字识别，所以v-bind可以直接识别html属性和css属性，但由于属性值实在千奇百怪，只能用字符串封装打包丢给相应解析器去处理。但是对于vue变量是可以直接识别的。这也就解释了为啥有时用引号有时不用。传统的字符串拼接使用引号表示字符串，加号表示变量，在es6中进一步简化为使用``封装所有字符，使用${}封装变量。'abc'+c+'de'=`abc${c}de`
109、理论上说所谓的最优解只是经济最优解，或者说
110、es6新引入了一种原始数据类型，用来表示独一无二的值，最大的用处是用来表示对象的唯一属性名，至此es6有7种数据类型，其中object包括数组，对象，函数都是可以使用new关键字定义的，其他的基本数据类型是不能使用new来定义的。对象在使用symbol属性时，是将symbol封装在变量里使用的，或许是出于字符长短的便利性角度考虑，所以不能用“.”而要用‘[]’。symbol值作为属性时，是共有属性，但是不能被for...in,for...of识别。要读取对象的symbol属性不能通过Object.keys()和Object.getOwnPropertyNames(),可以通过Object.getOwnPropertySymbols()和Reflect.ownKeys()。在一些函数内部使用symbol也可以进一步区分变量，以免不同的变量有相同变量值导致错误。es6新引入了一些objec类型，比如map和set，map用于存储键值对，传统对象只能存储无序存储以字符串作为key的键值对，但是map可以向数组一样有序存储一切键值对，key的类型不限制。set对象可以存储任何数据的唯一值。map有set和get方法，Set对象有add方法，Set对象常用于数组去重。
111、ES6新引入了object操作API，proxy和Reflect，proxy不是直接操作原始对象
112、她奶奶的，插件真不能用太多，bug满天飞，而且是那种莫名其妙的bug，自己出现自己消失，调试都找不到问题。他奶奶的，真是气死我了，一个二级路由页面怎么都调不出来，最后才发现是没有使用router-view，无论是一级页面还是二级页面，想要在原有页面上跳转，router-view和router-link都不能少，因为是单页应用，所以要配置router-link才能完成路径url跳转，同时也必须要有router-view才能显示路由页面，有时路由页面也必须配置页面层级才能显示出来。
113、vue组件传值中最常见也是最易弄混的就是子传父和父传子了，父传子要比子传父更加常用，父组件向子组件传值的特点可以归纳为父组件在使用子组件时先使用可变参数“:params”绑定一个变量，子组件再通过props来接收父组件传入的参数，然后就可以使用该参数绑定的变量了。而子组件向父组件传值就要稍微麻烦一点，子组件向父组件传值本质上是利用事件冒泡来完成的，所以子组件要先绑定一个事件@xxx，xxx内部通常只有一句this.$emit('arg1',this.arg2),其中arg1有名无实表示子组件传到父组件的事件，然后在父组件中绑定传入的事件arg1，再给父组件的arg2绑定方法(方法中可以默认接受子组件传入的arg2)
114、es6里对象内方法简写，对象内往往是方法名，具名或匿名函数，所以在es6里可以直接写具名函数
115、vue数据和视图双向绑定，也就是说视图里的数据才会双向绑定，没有被视图直接使用的数据就要手动去监听数据变化在执行相应操作了，vue监听使用watch，watch只能执行methods里定义的方法，不能自定义方法。vue不推荐直接操作DOM,如果需要操作dom,就要给相应的dom元素设置ref，vue框架内部有一个refs对象，包含了所有的ref对象。
116、天啊，又在这里犯了一次错，要记住v-bind是属性绑定，不是样式绑定，可以通过class和style去操作样式，但要谨记v-bind是属性绑定，样式操作必须放在style和class属性里。
