1、“···”ES6中拓展运算符，本质上是一种浅拷贝，用于复制对象，也可以和解构赋值连用，但必须放在最后。
2、解构赋值可以灵活地用来交换值，[a,b]=[b,a];
3、解构赋值接受函数返回值。
4、直接定义的匿名数组，数组中的值是放在windows全局下的，可以直接用a，b……访问。
5、数组和对象虽然都是对象，但数组是有序的，其有索引值，根据索引值查找内容，而对象是无序的，要查找对象内容只能通过属性值，for···in，对于数组而言是索引index，对于对象而言是属性名key。对象内容的获取，obj.key,这样key会作为字符串解析，不能用作对象遍历，obj[key],key会作为变量解析，可以用于对象遍历。基于index和key，数组的解构赋值按照顺序匹配，而对象的解构赋值按照key匹配，所以必须指定key值。对象的解构赋值中有一种高级用法，用于解决属性名冲突，foo:baz,在对象的解构赋值中，值是被传给了baz而不是foo。
6、在vue项目中，如果一个文件有“_”的前缀，一般表示这个文件在其他地方有引用，且编译器在编译时不会直接编译。
7、scss混合器，js代码复用产生了模块，UI复用产生了组件，html也可以通过vue循环简化书写过程，然而css代码的书写却一直较为繁琐，复用方法不多，现在css预编译器中的sass第三版scss中提出了混合器用于css代码的复用，通过@mixin前缀声明混合器，混合器中可以包含属性，css规则(css代码块)。通过@include前缀来使用混合器，复用的效率往往会因为复用传参这一高级用法而进一步提升复用效率。
8、scss文件是一种预编译文件，预编译文件在编译后会生成相应的css文件，但是有时候scss文件很多，却不需要生成太多的css文件，而scss有一个特殊的约定，即若scss文件的文件名以下划线开头，则scss就不会在编译时单独编译出css，而只是把这个文件用作导入，这样的文件称为局部scss样式文件，在scss中使用@import导入scss局部样式时，可以省略下划线前缀。css可以通过@import导入外部css文件，但是导入的外部css文件只会在执行到该处时才会调用，导致页面加载缓慢，而scss也有@import规则，但scss会在编译生成css文件时就把相关文件导入。css互相导入有继承关系，将局部scss导入全局scss，再将全局scss导入入口main.js,通常采用这种用法。
9、main.js是vue项目的入口，在这里导入的文件具有vue全局作用域，在这里通常引入vue,router,css,以及根组件app.vue,babel插件可以将es6转化为es5，但它只能转化语法，对于es6的api则无能为力，而babel-polyfill这个插件则可以将es6的api也进行转换。通过npm包安装的插件可以直接引用。
10、scss作为一种css预编译器，要使用就要先安装他的语法环境，node-sass，同时webpack在打包时，对于一些规格外的语言是无法直接识别的，要安装相应loader,如sass-loader.
11、vue web应用虽然可以使用浏览器原生的滚动条，但是由于各个浏览器样式的差异，滚动条样式差别较大，所以一般禁用原生滚动条，使用自定义的滚动条。将html和body的滚动条禁用：overflow：hidden;
12、固定定位一般是相对于视口进行定位的，但固定定位的元素的祖先元素具有transform时，固定定位不在相对于视口，而是相对于其transform的祖先元素。前端的发展很快，页面多终端适配，由rem，断点响应式页面，再到vm，rem+vm对页面的适配越来越好，可以说基础应用只要开发浏览器版本就好了，工程类应用才需要单机应用。
13、位置容器，在页面级组件中，我们都只是提供一些跟位置有关的容器，然后再把子组件填充进去，用于复用的组件我们是不写位置信息的，位置信息由调用组件的父组件定义和提供。
14、router-view路由容器，通过路由接入的页面都会在此容器中。
15、很多时候我们不用固定定位，因为固定定位的调整是完全独立的，不能随父元素变化，响应式差，通常使用相对定位来模拟固定定位。
16、组件一般用index命名，文件名index会被默认查找，vue、js、json后缀可以省略不写，所以引入组件只需写道目录一级。
17、组件,template；new vue(),export default{};分离式组件，一体式组件。export导出到了哪？（三块论述）
    (1)、new vue({})和export default{}的区别，前者是构造函数式创建一个vue实例，生成的是一个独立的vue实例，而后者是es6中模块的导出方式，从export default{}中的大括号可以看出导出的是一个对象，因为组件的复用，牵扯到子组件父组件的问题，而new vue({})创建的是独立的组件，子组件是用vue.extend(obj)方法建立的父子关系，所以需要传入一个对象参数，所以使用export default{}将相关参数封装成对象导出。由此也可以推出只要有父亲的组件都要用export default{}导出，而没有父亲的组件只有入口文件main.js里的vue实例，所以它使用new vue({})来创建。还有new vue({})里数据data是个对象data:{},而export default{}里数据data却是一个方法，而且数据是以一个对象来返回的，那是因为组件复用而对象又是地址传递，为了不让多个组件间的数据互相影响，使用函数和返回值。
    (2)、组件和模板template，组件是一种ui复用，最简单的组件仅有template组成，不过现实中谁会用这么简陋的组件，常用的组件我认为可以分为动态组件和静态组件，静态组件是写死的，由template和style组成，但大多数组件是动态组件，内容是活得，由template、style、script组成，数据，子组件，钩子函数，所有的高级用法都是靠script来完成的。
    (3)、一体式组件适用于小项目，缺点很多，不支持css，es5，预编译器，命名冲突，语法高亮。所以分离式组件(官方名叫做单文件组件)克服了以上缺点，应用十分广泛。
18、router-link可以作为块级元素，为router-link设置类名并设置样式，有时用router-link包裹独生子女央视无效，目前暂不知啥原因，所以使用router-link包裹复数子女吧。
19、router-link真的很厉害，以往点击效果往往需要先设置样类，再通过js循环保留激活项目样式清除其他项目样式。现在有了router-link直接设置一下激活样式就好了，其他的js代码router-link封装好了，不用管。
20、在main.js中引入的文件都具有全局作用域。组件之间js文件之间总之就好像是跨域一样，大家都是互相封闭的，谁也不认识谁，同时又共享入口文件main.js里声明的东西。
21、引入es6之后我们一般不在使用var,大多数的场景通过let和const就能解决，而且其实代码中很多数据都是静态的，后续业务层一般不变的，用const定义就好，只有很少一部分需要设置成变量let。
22、vue路由规则routes中的name属性好像看似没什么用，因为在规则中只要有path，component就行了。但其实name可以用来传参，也可以作为router-link的to的对象。
23、路由的页面加载默认是一次性加载所有页面，这样会让首页的加载速度变慢，vue还提供了一种懒加载方式，可以让路由涉及的代码在需要时再去加载。这里懒加载的语法是固定的，() => import('组件地址')，注意不能使用{}将import包裹起来，不然没法正确解析。
24、router-link高级路由跳转，是类似于a标签的点击跳转，可以自动变换地址栏，router-link的用法有两个:(1)、简单的<router-link to="/xxx"><router-link/>,to后可跟组件name和path，当to后的值是变量时to要加v-bind。(2)、更加高级的router-link :to="{}"传参，在跳转组件时传递参数，参数用数组封装，常见的路由参数有name/path,params,query,params表示路由地址后的第一级伪地址，query表示第二级伪地址，params，query也是一个对象，query里的键值对放在"?"后面。
25、异步操作，异步操作是啥？异步操作是从传统程序设计中引入的一个概念，要理解异步操作，就要先理解同步操作和线程，线程是cpu工作的基本单位，很多程序为了提高运行速度使用多线程技术--既同时在多个线程上处理数据操作，但刚开始的时候cpu是单核单线程的，程序在单线程上排队运行，这种程序运行方式叫做同步操作，但是就“同步”这两个字的理解似乎又不是这样，将异步操作，同步操作称为异轨操作，同轨操作更恰当一些。异步是并行，同步是串行。异步操作将部分操作从主线程中分离到子线程中运行，在主线程结束之后再将子线程上异步操作的结果注入主线程。异步操作的关键在于回调函数，也可以说异步操作的特征就是回调函数（为了数据的正确无误，必须将操作结果回调回主线程，浏览器会自动识别回调函数进行异步操作）。js是单线程的，为了实现异步操作，借助浏览器的力量，异步操作是在浏览器进程中进行的。***********************************************异步操作和同步操作从语义上的正确理解是执行顺序和书写顺序步调一致地叫做同步操作，执行顺序和属性顺序不一致的叫做异步操作。**************************************浏览器内核常驻线程有：gui渲染线程、JS引擎线程、事件触发线程、定时触发器线程，异步http请求线程。js解析时将事件，定时器，异步http进行异步操作，这些代码会丢给浏览器子线程处理，主线程完毕后，将异步结果（此时处于任务队列中）通过回调函数注入主进程。基本的回调函数式异步操作只能将dom操作，事件，定时器，ajax作为异步，因为这些是常见的耗时操作，使用这些异步操作的话，可以真正的利用多线程提高代码运行效率。如果自己的js代码里也有耗时操作又不涉及基本耗时操作的话，就需要自己用回调函数再加异步请求和异步响应封装高级的异步操作，但这样只是让代码运行效率提高，总的时长是一样的，并没有利用多线程。es6中引入了promise对象，简化了自定义异步操作的过程，promise对象中的回调会被放到任务队列中。*********************回调函数说白了就是被作为另一个函数参数的函数，回调函数本身没有同步异步之说，可以被用在同步处理也可以被用在异步处理，基本的回调函数异步操作只能把dom，事件，ajax，定时器进行异步处理。高级的promise可以将自定义代码段以为异步处理。同时又避免了回调地狱(3重以上的回调嵌套)。
26、引入图标字体时，千万别忘了图标字体要设置两个类名，一个公共类名，一个个性命名。有时会因为没有公共类名查找半天的问题。哎……衰！
27、并集选择器用的不多，但也不能忘记啊，就是直接连写，没有间隔。
28、slot，又称为插槽，是vue中的一个内容分发接口，在模板中创建插槽，组件在被调用时组件标签之间的值(所有任何类型的值)会被放入插槽中。插槽有匿名插槽和具名插槽。组件标签间的值默认放入匿名插槽，要放入具名插槽就要指定插槽名，<slot name="xxx">,<div slot="xxx">使用类似这样的结构就可以将值插入具名插槽。
29、flex布局的项目一旦设置定位，相关的flex属性会失效，解决方法是加一个壳。将flex容器和项目的外围再套一个壳，对最外围的壳添加定位。flex和fixed，absolute组合时会flex属性失效，因为这两种定位脱标，而flex和relative组合时flex相关属性不会失效，因为relative和flex都不会脱标。
30、flex布局和ellipsis存在冲突，flex项目中的省略号无法调出。目前认为这是一个浏览器的bug，解决方法有好几种，只是不知道哪一种最靠谱。(1)、text-align：center可以在文字不足以填满容器时，将文字居中显示，在文字超出容器且溢出隐藏时从起始位置显示文字。(2)、flex布局中的justify-content和align-item都是相对于容器居中对齐，在文字不足以填满容器时，居中显示，在文字超出容器时仍然将文字的中心位置和容器中心对其，以至于在文字超出容器时显示效果巨差。(3)、text-align可以很方便的用overflow:hidden;white-space:nowrap;text-overflow:ellipsis;将溢出的文字用省略号表示。但是将这三个属性在flex项目中直接使用的话，没有任何效果。但是flex项目好像只有一层，flex项目里面的其他容器不再和ellipsis冲突，所以将文字再封装一层就好。对封装后的文字设置以上三个样式后，就可以神奇的(其实也不神奇，就是flex布局只有一层，很多效果要对内封装，对外封装，因为flex和定位等很多原有属性冲突)将文字效果调整地和text-align一致，既不满时居中，溢出时从头显示末尾省略号。
31、props父组件调用子组件时传值，子组件中在props里定义一个形参，并使用这个形参，父组件在使用子组件时直接将实参传入，传参时可以传入一个常量，也可以传入一个变量，但是传入变量时必须在用":"(也就是v-bind)
32、有时字体过大，行高不足导致的部分字“掐头去尾”问题，只要把行高调成1.x即可。
33、任何编程语言都会留有跟错误相关的api，try、catch、throw、finally是js里跟错误相关的api，不同的编程语言之间具有很多相似性，基本语法的相似，自带api的相似性。try用于测试代码块，catch(err)用于和try搭配使用，当try中的测试代码存在错误信息时，catch会捕获到这一错误，并显示出来（catch会在捕获到错误后创建一个err对象，包含name和message）。throw是另一个搭配使用的api用于手动抛出一个错误，本质上是抛出了一个error对象，不管是手动抛出的错误还是try里检测到的错误，遇到错误都会直接跳到catch(error)里。fianlly用于在try和catch后执行，不管结果如何都会执行。
34、webstorm也太智能了吧，移动文件时会自动修改引用路径。对组件名称的更改会自动将所有引用里的名称也更改。
35、vue项目工程化时推荐建立公共组件和基础组件，所谓公共组件是完善的成型组件，其他页面和组件可以直接调用，而基础组件只是一些半成品，是抽离出的一些基本公共结构和样式，使用时要根据不同页面二次加工。vue项目要建立pages目录，components目录，base目录，而assets目录是默认存在的，需要在其中建立各种类型的资源文件夹。pages里每一个页面目录都包含众多组件，其中index组件是主组件，其它业务组件被填充到主组件中。页面相关的文件在页面文件夹里就近维护，pages以外的文件和文件夹都是共有的，这样一个项目结构是很妥善恰当的。
36、vue组件名(vue组件中的name属性对应的值)不能和html标签名冲突，不然会报错，当然这里就算报错，也是可以正常显示的。
37、vue中的一类特殊对象，prop对象，常用的props既是prop对象的集合，
prop对象可以指定类型，可以直接指定类型，如propa:Number,其中类型值不用引号引起来，当需要给prop对象指定多个属性值时采用如下形式：propb: {type:String,default:"s",require:true,isVaild:function(value){}},类型值不用引号，因为在js中，包装对象首字母大写，可以全局识别。不需要加引号作为字符串转换。type，default，require都是prop对象默认的key，不能更改。require表示父组件传值不满足时直接报错。在prop对象中可以自定义验证函数，也可以使用props自带的validator函数，但validator和自定义验证函数只能使用一个。
38、默认情况下，js和css一样只能使用自身定义的代码，如果要使用别的js和css代码，就必须引入这个文件，但是这样的话就必须把整个整个文件引入，不可避免地提高了代码冲突的可能性，为此，有了scss中的混合器mixin和es6中的模块export，这样一来使用include和import就能引入一部分代码，极大地减少了代码冲突。
39、windows认可的可执行文件有.exe,.bat,.cmd在命令行中运行的也只有这三种文件
40、slot插槽有匹配性，匿名html放入匿名插槽中，如果不给匿名html指定slot是没办法放入具名slot中的。vue组件模板template中必须用一个元素包裹，此元素可以是自定义的vue组件元素，既可以是子组件。因为各种声明之后可以被vue解析器解析为块级元素。不同的组件(子组件和父组件)之间可以使用相同的class名，样式不会冲突，解析器在解析时会自动添加区分页面级组件因为要引入很多子组件，所以给子组件加上一个容器，避免子组件间互相影响，也就是页面级组件仅提供一些容器和相应布局，子组件填充进容器即可。简单组件(只包含一个子组件)直接包裹子组件就行，不需要再在子组件外添加容器了。但是如果一个组件包含了两个及以上的子组件，就需要用容器包裹，因为这样可以分离式开发，不同的人负责不同的组件，并且父组件可以在不知道子组件的情况下完成开发。
41、有时候父组件传值传的值并不是我们想要的，但并不会报错，js解析器只能识别好像是六种基本错误吧，如果父组件传了一个我们不想要的值，导致没有出现想要的效果，我们是很难查出此类错误的。所以我们通常对此种情况进行传值校验，当传值是不想要的值时主动报错，帮助我们查找错误和dbug。
42、export default作为模块导出时，默认导出匿名模块，相应的在导入此匿名模块时要给它取个名字。而export导出是导出具名模块的，因为具名所以导入时不能自己再给它取另一个名字，导入时需要用花括号{}包起来模块名，这都是es6模块语法。
43、元素脱离文档流之后，因为不再是块级元素，自身的宽度萎缩，不会再占据整行，所以需要人为设置宽度。同时父元素会高度萎缩，所以要格外注意，将一个元素脱标时要考虑这两点。
44、vue组件和第三方插件往往会对元素预设一些类名，有时要实现相应的效果不得不参考他们的类名针对性的编码。
45、在某些情况下，错误是不可避免地，当我们预料到这个错误时，可以主动的抛出这个错误，通过throw，但是其实是建立一个Error对象，并抛出这个对象，这样预料内的错误不会导致程序中断，可以继续执行。
46、webstorm的代码补全和智能提示是依据其项目索引和缓存的，webstorm在打开项目时会更新索引。有时索引会出现一些奇怪的问题，导致项目跑不起来出错，此时可以通过file-invalidate caches/restart来清除和重建缓存。
47、es6箭头函数有三种情况：具名和匿名，有参和无参，单句和多句。eg:f=()=>{a+b}.谨记以下几点：箭头相连的是参数，匿名函数不写“f=”这样的结构，参数只有一个时“()”省略，语句只有一条时“{}和return”省略。当返回单语句对象时，必须将对象用“()”括起来。但是如果具名函数无参时，“()”不能省略，否则函数名会被当成参数。对参数和函数名的区分是通过“=>”来区分的。
48、data里只是定义数据，数据的操作函数的调用什么的不在能在data()里定义，不然无效。data里只放数据，不对数据进行操作。methods里只定义方法，不调用方法。调用方法在钩子函数和事件里调用。这些都是有严格定义的，不能不按照规定使用，不然虽然不会报错，但是操作会无效。外部函数的直接调用是不能操作内部数据的，内部数据的操作必须定义在methods里，而且钩子函数和事件只负责调用不能定义其他操作。
49、异步操作promise对象，promise对象有一个匿名函数作为参数，该匿名函数有两个函数作为参数，resolve和reject这两个函数有js引擎提供，作用是改变promise对象的状态并将异步操作的结果(成功时是value，失败时是error)传递出去。then则接受两个函数作为参数，分别是成功时的函数和失败时的函数，函数的参数分别是value和error。***********************************************promise对象新建后就会立即执行。
50、then()也是promise对象默认的函数，是有js引擎提供的。只有promise对象才能调用then(),then()和resolve()以及reject()函数都是事先有定义的：返回一个对象，对promise对象的状态值和返回值的定义。个人重写的部分具有较高的优先级，没有写的以默认为准。因为then()返回一个新的promise实例，所以才能链式调用。返回值会被传出去，作为新的then()的参数，且then()里的参数只是形参，实参会由vue自动填充，不用关心这一点。
51、created()和mounted()函数作为最常用的两个钩子函数，其区别主要是dom是否渲染成功。created是实例已经被创建，在这一步会完成数据观测，属性和方法的运算，watch/event事件回调，调用获取远程数据通常在这一步完成(通常指获取后台数据)。mounted中，dom已经被渲染，可以进行一些数据的填充。
52、v-if和v-show的区别，v-if是根据条件去渲染页面，v-show是根据条件去决定是否显示页面，有时swiper插件在没有获取到远程数据时就去渲染页面的话会带来一些bug，这里是轮播图的最后一页无法正常切换到第一页，此时只有给swiper加上v-if渲染条件即可，当获取到远程数据之后在进行渲染即可消除此bug。
53、在程序开发过程中，很少出现一些无意义的数字，为了提高语义化，往往将一些数字定义为常量或变量。
54、promise.catch()就相当于promise.then(null,reject)或promise.then(undefined,reject),当异步失败或遇到错误或者是主动抛出错误时，就被catch捕获，程序自动跳转到catch中。
55、一般来说无论是axios，jsonp，ajax等前后端数据交互时都应该定义请求配置如超时什么的，不然数据出不来有找不到错误就尴尬了。
56、解构赋值的全称为变量的解构赋值，也就是说常量const是不能进行解构赋值的。
57、data里的属性和mothods里的方法要用this才能访问。then()这个方法是可以连续调用的，且promise中的每一个then的参数都是上一个then方法的返回值。
58、promise嵌套和链式调用。setTimeout()参数问题？setTimeout()的函数参数常常是匿名函数，因为超时调用是以后调用，所以不能写成函数调用，写成函数的形式又不能灵活传参，所以常常写成匿名函数的形式，干脆就记住只能写成匿名函数得了。当然还可以将带参函数用单双引号搭配使用以完成参数传递
59、vue别名和“~”，在webpack.base.config.js文件中可以使用alise，通常自带@表示src目录，还可以自己定义一个‘#’，使用resolve('src/……')来定义别名，至少在vue2.x中是这样的，不过CSS-loader(webpack中的css解析器)会把非根路径的url解释称相对路径，加了‘~’前缀才能解析成模块路径。在vue里路径可以分为绝对路径和相对路径以及模块路径(使用别名减少路径长度的方法就是引入了模块路径)。所以使用css引入模块路径时要加上前缀‘~’。
60、前端开发中各种命名规范，命名规范的好处是语义化便于理解(当然这里的便于理解是因为通常命名时使用多个单词的组合)，同时便于语法检查(多个单词的直接组合有时会被ide标记，有时错误的单词拼写也会被标记，多个单词使用“-”或“_”组合而不是直接组合就不会被ide标记，这样就提高了真正错误被发现的概率)。通常项目组会有相应的命名规范统一各个部分的命名。在个人开发过程中，如果条件允许建议使用“_”来，因为单词的直接组合并不具有机器语义，不利于ide识别，而unix,linux,和很多标准组织对下划线的支持度更好，所以不到万不得已不要使用单词直接连接或驼峰命名，可以的情况下最好使用“_”。而且单词直接连接和驼峰法性能较差。更：***************************css中“_”有兼容性问题，所以css语法才会强调使用“-”。综上所述，这个前端还真是尴尬，js要用驼峰，css要用“-”，其余的要用“_”或“-”。尴尬的一批。
61、项目依赖的包最好不要全局安装，因为一旦全局安装后，在构建别人发来的项目时，检测到全局存在就不会安装已经全局存在的依赖，事实上有可能全局存在的包和项目依赖的包版本号不一样，有可能依赖的兼容性不佳导致版本号不同而构建失败。还有npm包的范围详细的可分为本地安装和全局安装，本地安装是在当前目录下安装，默认会在当前目录下建立./node_modules文件夹用来放置依赖，本地安装只在项目目录下可用。全局安装又分为系统全局安装和用户全局安装，系统全局安装的依赖被放在node安装目录下的node_modules目录中，不同用户都能使用。用户全局安装的依赖被放在用户目录下的node_modules目录中，默认全局安装就是用户全局安装。
62、npm与cnpm，cnpm安装依赖时有时会遗漏部分依赖，且错误信息的提示不太准确，有时cnpm没有报错，项目却跑不起来。npm报错信息准确，有错就跑不起来。有时项目的错误如果不是自身编码的错误那就一定是环境和依赖的问题，环境的问题一般因为兼容性很少出现，依赖的问题倒是经常出现，其实可以直接删除依赖node_modules文件夹，然后再重建一般就解决了问题。那么这个问题往往是因为项目建立时使用cnpm install安装了项目依赖，然而使用cnpm会导致在使用npm时缺少很多依赖库，无法运行。所以不能用cnpm。而且在自主安装依赖时一定要明确是开发时依赖还是生产时依赖，这对项目的实际上线时的大小和流畅度至关重要。
63、有时项目依赖的层级很深，互相依赖了好多层，导致无法删除依赖，此时可以使用rimraf来删除。
64、git中https和ssh的异同，使用ssh必须实现配置公钥，验证通过才能clone，https可以直接clone。但是https在push时每次都需要验证用户名密码，而ssh不需要验证，可以直接推送。通过git pull拉取代码来更新项目比下载压缩包方便也合理，直接下载压缩包是下载了最新版文件不包含git和一些特殊的文件。
65、双斜杠加todo会形成todo标记，在todo后面的代办项会在todo标签里显示，可以很快从中断的工作中恢复。
66、不正确的关闭或者网络问题会导致依赖包错误，产生一些莫名其妙的错误，需要删除依赖重新下载。
67、在vue-cli是vue-cli 2.x，而vue-cli 3.0以上因为有重大改动，所以改名叫vue/cli，其中一处改动是alias别名设置，在vue-cli中vue别名需要在webpack中设置，而且css中的别名要加上“~”前缀。****************************************(～￣▽￣)～大更新，原来一直以来的alias别名使用失败，是因为没有在webstorm中导入webpack的配置文件。
68、在项目中安装依赖 --save表示安装到生产环境，但其实在生产环境和开发环境都可以使用，所以我觉得前面说的“--save表示安装到生产环境”说法不准确，是一种陋习，叫做安装到生产和开发环境较为准确。--save-dev是安装到开发环境，跟webpack相关的依赖都是建议安装在开发环境，因为webpack只工作在生产环境之前。
检出仓库（checkout）本质是clone仓库的衍生版，一个git仓库有三部分组成，工作区（workspace），暂存区（index），最终区（head），工作区add到达暂存区，暂存区commit到达head区，从逻辑上将每次commit都是把暂存区提交到最终区，所以必须执行add将修改提交到暂存区。但是“commit -a”命令可以将add和commit结合，自动先执行add，然后执行commit。checkout是检出的意思，可以灵活的切换分支，要切换分支就要先建立分支，git breach xxx
